

                                                                                   


                                                             %%%   ADVANCED COUNTING   %%%
\chapter {Advanced Counting}
\section {Recurrence Relations}
Understanding recurrence relations is important to the analysis of recursive algorithms. 
linear, homogeneous, coefficients

\begin{definition}
A \textit{recurrence relation} for the sequence $\{a_n\}$ is an equation that expresses $a_n$ in terms of one or more of the previous terms of the sequence, namely, $a_0,a_1, \dots ,a_{n-1}$, for all integers $n$ with $n \ge n_0$, where $n_0$ is a nonnegative integer. A sequence is called a \textit{solution} of a recurrence relation if its terms satisfy the recurrence relation.
\end{definition}

\begin{notes}
Carefully note why they are relations and not functions. The initial conditions determine the sequence.
\end{notes}

    \subsection {Modeling with Recurrence Relations}
Compound interest formulae, Fibonnaci sequence, Catalan numbers
    
\section {Solving Linear Recurrence Relations}
  \subsection {Types of Recurrence Relations}

    \begin{definition}
    A \textit{linear homogeneous recurrence relation of degree ke with constant coefficients} is a recurrence relation of the form
    $$ a_n=c_1a_{n-1} + c_2a_{n-2}+ \dots + c_ka_{n-k}$$
    where $c_1, c_2, \dots c_k$ are real numbers, and $c_k \neq 0$
    
    \end{definition}

Linear recurrence relations have a sum of previous terms multiplied by some function of $n$.

Homogeneous recurrence relations have no terms that are not multiples of an $a_j$.

Constant coefficients ensure there are no functions on $n$ as coefficients.

Degree is the $k$ in the definition.


    It is \textbf{linear} because the RHS is a sum of previous terms of the sequence each multiplied by a function of $n$ and \textbf{homogeneous} because no terms occur that are not multiples of the $a_j$s. All the coefficients are constants rather than functions on $n$. The \textbf{degree} is $k$. 

Because linear homogeneous recurrence relations with constant coefficients occur so frequently in the analysis of algorithms, we limit our discussion to them. To see how more advanced recurrence relationships are solved the student should see                                                           

  \subsection {Solving Linear Homogeneous Recurrence Relations with Constant Coefficients}
  
  \subsubsection{Example 6.10 from Schaum's}
  Consider the following homogeneous recurrence relation:
  \begin{displaymath}
  a_n=2a_{n-1}+3a_{n-2}
  \end{displaymath}
  The general solution is obtained by first finding its characteristic polynomila $\Delta(x)$ and its roots $r_1$ and $r_2$:
  \begin{displaymath}
  \Delta(x)=x^2-2x-3=(x-3)(x+1); \text{roots} r_1=3, r_2=-1
  \end{displaymath}
  Since the roots are distinct, we can use Theorem x to obtain the general solution:
  \begin{displaymath}
   a_n=c_13^n+c_2(-1)^n
  \end{displaymath}
  Any values for $c_1$ and $c_2$ will give \textit{a} solution to the recurrence relation.
  
  Suppose we are also given the initial condition $a_0=1,a_1=2$. Using the recurrence relation we can compute the next few terms of the sequence:
\begin{displaymath}
  1,2,7,20,61,\cdots
  \end{displaymath}
  
  The unique solution is obtained by finding $c_1$ and $c_2$ using the initial conditions. Specifically:
 
  \begin{align*}
  \text{For } n=0 \text{ and } a_0=1,  &\text{ we get: }  c_13^0+c_2(-1)^0=1   &\text{ or }  & c_1+c_2=1\\
  \text{For } n=1 \text{ and } a_1=2,  &\text{ we get: }  c_13^1+c_2(-1)^1=2   &\text{ or } & 3c_1-c_2=2
 \end{align*}  
 Solving the system of two equations in the unknowns $c_1$ and $c_2$ yields:
 \begin{displaymath}  
 c_1=\frac{3}{4} \text{and} c_2=\frac{1}{4}
 \end{displaymath}
 Thus the following is the unique solution of the given recurrence relation with the given initial conditions $a+0=1,a_1=2$:
 \begin{displaymath}
 a_n=\frac{3}{4} 3^n + \frac{1}{4} (-1)^n = \frac{3^{n+1}+(-1)^n}{4}
 \end{displaymath}

\section {Divide-and-Conquer Algorithms and Recurrence Relations}
give one homework with a recursive algorithm and ask for closed form solution for time function complexity.

\section {Generating Functions}

\begin{definition}
The \textit{generating function for the sequence} $a_0,a_1,\dots ,a_k, \dots$ of real numbers is the inifinite series
$$G(x)=a_0+a_1x+ \dots + a_kx^k+ \dots = \sum_{k=0}^\infty a_kx^k$$
\end{definition}

    \subsection {Counting Problems and Generating Functions}

\section {Inclusion-Exclusion}
  \subsection{The Principle of Inclusion-Exclusion}
  \subsection{Applications of Inclusion-Exclusion}
  \subsection{An Alternative Form of Inclusion-Exclusion}
  \subsection{The Sieve of Eratosthenes}
  The Sieve of Eratosthenes is an algorithm for making tables of primes. Sequentially write down the integers from 2 to the highest number $n$ you wish to include in the table. Cross out all numbers >2 which are divisible by 2 (every second number). Find the smallest remaining number >2. It is 3. So cross out all numbers >3 which are divisible by 3 (every third number). Find the smallest remaining number >3. It is 5. So cross out all numbers >5 which are divisible by 5 (every fifth number).

Continue until you have crossed out all numbers divisible by $\lfloor\sqrt{n}\rfloor$. The numbers remaining are prime. 

The sieve of Eratosthenes can be used to compute the prime counting function as
$$\pi(n) = \lfloor n \rfloor- \sum_i\left\lfloor \frac{n}{p_i} \right\rfloor + \sum_{i<j} \left\lfloor{ \frac{n}{p_ip_j}}\right\rfloor \dots$$
  \subsection{The Number of Onto Functions}
  \subsection{Derangements}


    \subsection {Natural Number Functions}
    \subsection {Limits on Computability}
        \subsubsection {Not Everything is Countable}
        \subsubsection {There are uncountably many languages over a finite alphabet}
    \subsection {Inductively Defined Infinite Sets}
The set of natural numbers can be completely defined with the statements that zero is a member of the set, that for all n in the set that succ(n) is a member of the set and that only elements from these two statements exist in the set. 


Theorem: The set $\mathbb{R}$ is NOT countably infinite. We call the cardinality of all countably infinite sets $\aleph _0$ pronounced aleph-null. Sets that can be put into a bijection with the set of reals is said to have cardinality $\aleph_1$


The algorithm to calculate a factorial has the simple open form solution of 
$\Pi{1*2*3* ... *n}$

This gives us a simple iterative algorithm to calculate n!

factorial(n)
fact=1
for i=1 to n
    fact=fact*i
return fact

However there is another algorithm that has appeal.

factorial(n)
if n==0
    return 1
else
    return n*(factorial(n-1) )

The appeal is the simplicity but the novelty is that the function CALLS ITSELF, a recursion. In general every iterative algorithm can be converted to a recursive algorithm and vice versa. They occur enough in computer science that we need to look at how we look at the time complexity functions they create.

Level Number
With recursive algorithms, it is helpful to track how many times the algorithm has called itself. We define a level number to be one the first time it is called and one greater with each recursive call.

Some famous sequences derived from recursive functions
Fibonacci is famous because it was created to capture the reproduction pattern of rabbits but is found abundantly in nature.

Fib(n)
if n==0
    return 0
else if n==1
    return 1
else 
    return (Fib(n-1) + Fib(n-2))

When used on the set of natural numbers we get the sequence
0,1,1,2,3,5,8,13,21,34,55, ...

Ackermann
Famous for a function that is easily defined but has an explosive growth curve. To evaluate the Ackermann function for even the trivial value of Ackermann(1,3) requires 15 steps.

Ackermann(m,n)
if m==0
    return n+1
else if m !=0 and n==0
    return Ackermann(m-1,1)
else (m!=0 and n!=0)
    return Ackermann((m-1),Ackermann(m, n-1) )


Recursive Relations and their Closed Form Solutions

Recursive definition of sets

\newpage
